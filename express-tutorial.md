Mosh express tutorial - https://www.youtube.com/watch?v=pKd0Rpw7O48

### Jump to [Summary](#Summary)

### Express is fast, lightweight and well documented
- npmjs.org, search for express
- express js docs on expressjs.com, click API Reference on the top, click Request obj on the left

### REST is a convention for building services to perform CRUD operations.

e.g url for a REST api - vidly.com/api/customers
- you can use api.vidly.com as well. It's just a name.
- `customers` is a resource. Other resources - movies, retals. Resources are served on endpoints.

> ### REST Terminology  
> 1) Resource - data set which is to be returned or to be operated on, mentioned in the request.
> 2) Endpoint - the URL used to make the request.

### Standard HTTP methohds -
- GET
- POST	- creating data
- PUT 	- update data
- DELETE

Examples -
- `GET /api/customers` - will return a list of customer objects - [{id:'1',name:''}, {id:'2'}]
- `GET /api/customers/1` - will return a customer with the id provided - {id:'1',name:''}
- `PUT /api/customers/1` - modify the customer with id=1, include customer obj in body of request - {name: ''}. Also, return the modified object.
- `DELETE /api/customers/1` - return the obj deleted.
- `POST /api/customers` - include customer object in body, w/o id. Also, return the new object created - the client may need the id generated.

# Basics - app.js
```javascript
const express = require('express');
const app = express();				// some object creator?

app.get('/', (req, res) => {
	res.send('Hello World');
});

app.get('/api/courses', (req, res) => {
	// some code to fetch data from DB
	res.send([1, 2, 3]);			// no need for JSON.stringify()?
});

app.listen(3000, () => console.log('Listening on port 3000...'));
```

> Instead of the if statements inside a function, we have separate functions. So, you can have all the requests dealing with /api/courses in a separate module(file). Express gives our application some structure.

## Nodemon	- Node Monitor
- Don't have to restart server by Ctrl+C and node app.js every time(to reload new files in memory). // This is a small change like not having to compile & run code each time, like in Java but it so convenient & stops you looking for bugs when you didn't restart the server
- `nodemon app.js` 			// instead of node app.js
- _watching \*.\*_ means it montiors all files with all extensions for changes

## Fixing the port no. using env var
- A fixed port is alright for dev environment, but it won't work on a production environment.
- In a hosting environment, the port is dynamically assigned by the environment using the environment variable.
- in the terminal, type - `export PORT=5000` to try it out.

```javascript
const port = process.env.PORT || 3000;	// || can sift out null or undefined
app.listen(port, () => console.log(`Listening on port ${port}...`));
```

Note: Environment variables can also be set in the `.env` file.

## Route Parameters - To collect data from the url
> e.g - localhost:3000/api/courses/1		// denotes the course_id
```javascript
app.get('api/courses/:id', ...
	res.send(req.params.id);
```
> 1

> e.g - localhost:3000/api/posts/2018/1	 	// denotes year and month
```javascript
app.get('api/courses/:year/:month', ...
	res.send(req.params);
```
<pre>
{
	year: "2018",
	month: "1"
}
</pre>

## Query Parameters - To collect additional data for the backend
> e.g - localhost:3000/api/posts/2018/1?sortBy=name
```javascript
app.get(...
	res.send(req.query);
```
<pre>
{
	sortBy: "name"
}
</pre>

### Parameter usage -
1. Route parameters - `req.params`	- compulsary data
2. Query parameters - `req.query`	- optional data or metadata

# Handling GET Requests
```javascript
let courses = [];	// global var. in module

app.get('/api/courses/:id', (req, res) => {
	let course = courses.find(c => c.id == req.params.id)	// .find() is a method for all arrays	// == is used instead of === since c.id is an int and params.id is a string
	if (!course) res.status(404).send(`The course with id: ${req.params.id} is not found`);
	// Chaining of .status() and .send() is possible. Nice!
});
```
> - It is a standard practise in REST to return 404 RESOURCE NOT FOUND as a response when the request fails. This can be observed in the network part in chrome dev tools.
> - The default status for a response is 200 OK.

# Handling POST Requests
```javascript
// req.body is a json string, to get its .name attribute, we need to enable json parsing in express
app.use(express.json())
// express.json() returns a middleware, which we are asking it to use in the request processing pipeline

app.post('/api/courses/', (req, res) => {
	const course = {
		id: courses.length + 1, // actually id should be generated by DB
		name: req.body.name
	};
	courses.push(course);
	res.send(course);
});
```

## Postman to test POST endpoints
- Install the postman extension. Type in your URL and select POST.
- Click on "Body", select "raw" with type "JSON"
- Add the JSON object in text, click send and check the response.

## Validating request input
- **Never trust the user to send a valid input.**
```javascript
app.post(...
	if (!req.body.name || req.body.name.length < 3) {
		// 400 Bad Request
		res.send(400).send('Name is required & must be minimum 3 chars');
		return;
	}

	courses = ...
```
- These validations can get complicated & hard to read, with large no. of variables.
- We can use the **joi** package to simplifiy a large no. of validations.
- First, install it using npm, then replace the above code with
```javascript
Joi = require('joi');
app.post(...
	const schema = {
		name: Joi.string().min(3).required()
	};

	const result = Joi.validate(req.body, schema);
	if (result.error) {
		res.status(400).send(result.error.details[0].message);
		return;
	}

	courses = ...
```
> - result.error is an object.
> - error.details is an array containing the errors caught in validation. You can just show the first error message & as they correct each one they'll see the next one.
> - You don't need to remember the syntax error.details[0].message, just print the object & look it up.
> - To test it out, send the foll. json strings - {} and {"name":"g"}

# Handling PUT requests
### Template -
```javascript
app.put('/api/courses/:id', (req, res) => {
	// Look up the course
	// If not existing, return 404

	// Validate
	// If invalid, return 400

	// Update course
	// Return the updated course
});
```
> - The first section can be copied from app.get()  
> - The second section can be copied from app.post(), but since there are multiple lines of common code, we'll write a function to handle that *during refactoring*.
> - Third section is easy to implement
### Refactored 2nd section -
```javascript
// note that the error message will need to extracted in and sent in the original function itself. But, can't we pass res?
function validateCourse(course) {
	const schema = {
		name: Joi.string().min(3).required()
	};
	return Joi.validate(course, schema);
}

app.put(...
	const {error} = validateCourse(req.body);
	if (error) {
		res.status(400).send(error.details[0].message);
		return;
	}
);
```
> - {error} is a *"destructuring assignment"*, in js.
> -  This was used we only needed the *error* attribute from the *result* object.
> - Another e.g - `[a, b] = [10, 20]`
> - This is used in Python all the time, say we return 2 things from a function, we use a tuple to store the values in 2 variables.

# Handling DELETE requests
### Template -
```javascript
app.post('/api/courses/:id', (req, res) => {
	// Look up course
	// If does not exist, return 404

	// Delete

	// Return the deleted course obj
})
```
> Section 1 and 3 can be copied from above.
### Section 2 code -
```javascript
app.post(...
	// course is returned given its index in section 1 using courses.find()

	// Delete
	const index = courses.indexOf(course);
	courses.splice(index, 1)
```
> - `.find()` returns object given its index & `.indexOf()` returns index given the object.
> - `.splice(index, n)` deletes `n` objects starting from `index`

# Summary
> ## Which Status to Return?
> 1. `404 RESOURCE NOT FOUND` - when the resource was not found on the **server**.
> 2. `400 BAD REQUEST` - When the **request** contains missing or invalid data. e.g - `name.string().required().min(3)` or `id.int().required()`
> 3. `200 OK` - default response status.

> ### REST Terminology  
> 1) Resource - data set which is to be returned or to be operated on, mentioned in the request.
> 2) Endpoint - the URL used to make the request.

### Parameter usage -
1. Route parameters - `req.params`	- compulsary data
2. Query parameters - `req.query`	- optional data or metadata

***
# Other Takeaways
## Good coding practices
- When copy pasting code you've already written somewhere else, don't immediately think about can I use a function to modularize it or are 2 repetitions too less? **Refactor the code later**. Always use refactoring as an excuse to get code completed and go into the tough decisions later. *Because working code is better than well designed but non-working code*.
- When creating a function, start by write comments to describe the main steps(block of code) in the function. e.g - the callback in app.put() before starting to code.
	``` 
	app.put('/api/courses/:id', (req, res) => {
		// Look up the course
		// If not existing, return 404

		// Validate
		// If invalid, return 400

		// Update course
		// Return the updated course
	});
	```